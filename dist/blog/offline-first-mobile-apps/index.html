<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon-dark.svg" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/favicon-light.svg" media="(prefers-color-scheme: light)"><link rel="icon" type="image/x-icon" href="/favicon-light.svg"><meta name="generator" content="Astro v4.5.6"><!-- Font preloads --><link rel="preload" href="/_astro/inter-latin-400-normal.BT1H-PT_.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/inter-latin-600-normal.B2Ssfs8e.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-400-normal.CvHVDnm4.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-600-normal.DUWh3m6k.woff2" as="font" type="font/woff2" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://astro-nano-demo.vercel.app/blog/offline-first-mobile-apps/"><!-- Primary Meta Tags --><title>Offline First Mobile Apps | Marcos von Stremayr</title><meta name="title" content="Offline First Mobile Apps | Marcos von Stremayr"><meta name="description" content="Creating Mobile Apps with an &#34;Offline First&#34; Approach in Flutter"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://astro-nano-demo.vercel.app/blog/offline-first-mobile-apps/"><meta property="og:title" content="Offline First Mobile Apps | Marcos von Stremayr"><meta property="og:description" content="Creating Mobile Apps with an &#34;Offline First&#34; Approach in Flutter"><meta property="og:image" content="https://astro-nano-demo.vercel.app/nano.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://astro-nano-demo.vercel.app/blog/offline-first-mobile-apps/"><meta property="twitter:title" content="Offline First Mobile Apps | Marcos von Stremayr"><meta property="twitter:description" content="Creating Mobile Apps with an &#34;Offline First&#34; Approach in Flutter"><meta property="twitter:image" content="https://astro-nano-demo.vercel.app/nano.png"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script>
  function init() {
    preloadTheme();
    onScroll();
    animate();

    const backToTop = document.getElementById("back-to-top");
    backToTop?.addEventListener("click", (event) => scrollToTop(event));

    const backToPrev = document.getElementById("back-to-prev");
    backToPrev?.addEventListener("click", () => window.history.back());

    const lightThemeButton = document.getElementById("light-theme-button");
    lightThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "light");
      toggleTheme(false);
    });

    const darkThemeButton = document.getElementById("dark-theme-button");
    darkThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "dark");
      toggleTheme(true);
    });

    const systemThemeButton = document.getElementById("system-theme-button");
    systemThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "system");
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    });

    window.matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", event => {
        if (localStorage.theme === "system") {
          toggleTheme(event.matches);
        }
      }
    );

    document.addEventListener("scroll", onScroll);
  }

  function animate() {
    const animateElements = document.querySelectorAll(".animate");

    animateElements.forEach((element, index) => {
      setTimeout(() => {
        element.classList.add("show");
      }, index * 150);
    });
  }

  function onScroll() {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }
  }

  function scrollToTop(event) {
    event.preventDefault();
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  }

function toggleTheme(dark) {
    const css = document.createElement("style");

    css.appendChild(
      document.createTextNode(
        `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
      )
    );

    document.head.appendChild(css);

    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }

  window.getComputedStyle(css).opacity;
    document.head.removeChild(css);
  }

  function preloadTheme() {
    const userTheme = localStorage.theme;

    if (userTheme === "light" || userTheme === "dark") {
      toggleTheme(userTheme === "dark");
    } else {
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }

  document.addEventListener("DOMContentLoaded", () => init());
  document.addEventListener("astro:after-swap", () => init());
  preloadTheme();
</script><link rel="stylesheet" href="/_astro/_slug_.C1Wy-C9s.css" /><script type="module" src="/_astro/hoisted.IxFg9jpS.js"></script></head> <body> <header> <div class="mx-auto max-w-screen-sm px-5">  <div class="flex flex-wrap gap-y-2 justify-between"> <a href="/" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out">  <div class="font-semibold"> Marcos von Stremayr </div>  </a> <nav class="flex gap-1"> <a href="/blog" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
blog
 </a> <span> / </span> <a href="/work" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
work
 </a> <span> / </span> <a href="/projects" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
projects
 </a> </nav> </div>  </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-5">  <div class="animate"> <a href="/blog" class="relative group w-fit flex pl-7 pr-3 py-1.5 flex-nowrap rounded border border-black/15 dark:border-white/20 hover:bg-black/5 dark:hover:bg-white/5 hover:text-black dark:hover:text-white transition-colors duration-300 ease-in-out"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute top-1/2 left-2 -translate-y-1/2 size-4 stroke-2 fill-none stroke-current"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 group-hover:translate-x-0 scale-x-0 group-hover:scale-x-100 transition-transform duration-300 ease-in-out"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 group-hover:translate-x-0 transition-transform duration-300 ease-in-out"></polyline> </svg> <div class="text-sm"> 
Back to blog
 </div> </a> </div> <div class="space-y-1 my-10"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> <time datetime="2024-04-23T03:00:00.000Z"> Apr 23, 2024 </time> </div>
&bull;
<div class="font-base text-sm"> 19 min read </div> </div> <div class="animate text-2xl font-semibold text-black dark:text-white"> Offline First Mobile Apps </div> </div> <article class="animate"> <p>In today’s interconnected world, users expect mobile applications to be available and responsive at all times, regardless of their network connectivity. However, relying solely on a stable internet connection can pose challenges, especially in areas with poor connectivity or when users are traveling. This is where the “Offline First” approach comes into play.</p>
<p>The “Offline First” approach prioritizes the functionality and user experience of an application even when there is no internet connection available. By designing applications to work seamlessly offline and syncing data with servers when a connection is available, developers can enhance the reliability and accessibility of their mobile apps.</p>
<p>In this blog post, we’ll explore the concept of “Offline First” and its significance in mobile app development. We’ll discuss the benefits of adopting this approach and provide practical strategies for implementing it in Flutter, Google’s UI toolkit for building natively compiled applications for mobile, web, and desktop from a single codebase.</p>
<p>Let’s dive in and discover how to create mobile apps that excel in both online and offline scenarios using Flutter’s powerful features and best practices.</p>
<h3 id="what-is-the-offline-first-approach">What is the Offline First Approach?</h3>
<p>The “Offline First” approach is a development strategy that prioritizes the offline functionality of an application. Unlike traditional approaches where applications rely heavily on continuous internet connectivity, an “Offline First” approach ensures that the application remains functional even when offline, with seamless synchronization of data when an internet connection is available.</p>
<p>At its core, the Offline First approach aims to provide users with a consistent and reliable experience regardless of their network status. This means users can access key features, perform actions, and view content even in environments with limited or no connectivity.</p>
<p>By designing applications with offline capabilities from the outset, developers can address common challenges such as network latency, intermittent connectivity, and data usage limitations. This not only improves the user experience but also reduces reliance on a stable internet connection, making the application more resilient and accessible to a wider audience.</p>
<p>In the context of mobile app development, implementing an Offline First approach involves several key strategies, including local data storage, background data synchronization, and robust error handling. These strategies ensure that users can interact with the app seamlessly, regardless of their network conditions.</p>
<h3 id="benefits-of-offline-first-mobile-app-approach">Benefits of Offline First Mobile App Approach</h3>
<ol>
<li><strong>Improved User Experience</strong>: By enabling offline functionality, users can access and interact with the app’s core features even when they are not connected to the internet. This ensures a consistent and seamless user experience, leading to higher user satisfaction and engagement.</li>
<li><strong>Reduced Dependency on Network Connectivity</strong>: With an Offline First approach, mobile apps are less reliant on a stable internet connection. Users can continue using the app in areas with poor or no connectivity, such as underground transportation or remote rural areas, without experiencing interruptions.</li>
<li><strong>Optimized Performance</strong>: Offline First apps often perform better than their online-only counterparts due to reduced network requests and faster local data access. This results in faster load times, smoother navigation, and overall better performance, enhancing the app’s usability and appeal.</li>
<li><strong>Cost Savings for Users</strong>: Offline First apps can help users save on data costs by minimizing the need for continuous data usage. Users can download content and perform actions while connected to Wi-Fi, reducing their reliance on expensive mobile data plans.</li>
<li><strong>Increased Accessibility</strong>: By accommodating users with limited or intermittent internet access, Offline First apps become more accessible to a broader audience. This includes users in developing regions, travelers, or those with limited data plans, who may otherwise struggle to use online-only applications reliably.</li>
<li><strong>Data Security and Privacy</strong>: Storing data locally on the device enhances security and privacy, as sensitive information remains within the user’s control. Offline First apps often employ encryption and other security measures to protect user data, reducing the risk of data breaches or unauthorized access.</li>
<li><strong>Seamless Synchronization</strong>: Offline First apps seamlessly synchronize data with servers when an internet connection is available, ensuring that users’ data remains up-to-date across devices. This enables users to switch between online and offline modes without losing their progress or data.</li>
</ol>
<p>By leveraging the Offline First approach, developers can create mobile apps that are more resilient, user-friendly, and accessible, catering to the diverse needs of modern users in an increasingly connected world.</p>
<h3 id="strategies-for-implementing-offline-first-in-flutter">Strategies for Implementing Offline First in Flutter</h3>
<ol>
<li><strong>Local Data Storage</strong>:
<ul>
<li>Utilize local storage solutions like SQLite databases or key-value stores (such as shared_preferences) to store essential app data locally on the device.</li>
<li>For structured data storage, use Hive, a lightweight and fast NoSQL database solution for Flutter, providing efficient local storage capabilities.</li>
</ul>
</li>
<li><strong>Background Data Synchronization</strong>:
<ul>
<li>Implement background data synchronization to update local data with the server when the device is online.</li>
<li>Use packages like dio for making HTTP requests and implement background tasks with the help of plugins like workmanager or background_fetch to synchronize data periodically or in response to specific events.</li>
</ul>
</li>
<li><strong>Offline Capabilities for UI</strong>:
<ul>
<li>Design UI components to gracefully handle offline scenarios, such as displaying cached data, disabling certain features, or providing informative messages to users.</li>
<li>Utilize Flutter’s state management solutions like Provider or Riverpod to manage UI state and conditionally render UI elements based on the app’s online/offline status.</li>
</ul>
</li>
<li><strong>Data Caching and Prefetching</strong>:
<ul>
<li>Cache frequently accessed data locally to reduce the need for network requests.</li>
<li>Implement prefetching mechanisms to proactively fetch data in the background when the device is online, ensuring a smooth user experience even in offline mode.</li>
</ul>
</li>
<li><strong>Error Handling and Recovery</strong>:
<ul>
<li>Implement robust error handling mechanisms to gracefully handle network errors, server timeouts, and other connectivity issues.</li>
<li>Provide feedback to users about the status of data synchronization and guide them on how to resolve any connectivity-related issues.</li>
</ul>
</li>
</ol>
<p>By implementing these strategies, developers can create Flutter apps that offer robust offline capabilities while maintaining a smooth and reliable user experience across different network conditions.</p>
<h2 id="practical-example-building-an-offline-first-todo-app-with-flutter">Practical Example: Building an Offline First ToDo App with Flutter</h2>
<p><strong>Introduction:</strong></p>
<p>In this practical example, we’ll build an Offline-First ToDo app using Flutter. The app will allow users to create, read, update, and delete ToDo items both online and offline. We’ll cover several modules:</p>
<ol>
<li><strong>Data Models</strong>: Define the models for ToDo items and remote operations.</li>
<li><strong>Local Storage Service</strong>: Implement local storage operations using Hive.</li>
<li><strong>Remote Service</strong>: Implement remote CRUD operations using Dio.</li>
<li><strong>Repository Layer</strong>: Define repositories for managing data operations.</li>
<li><strong>BLoC Layer</strong>: Implement BLoCs for business logic and state management.</li>
<li><strong>UI Layer</strong>: Develop the UI components using Flutter.</li>
</ol>
<p><strong>Project Setup:</strong></p>
<ul>
<li>Create a new Flutter project.</li>
<li>Add the required packages to your <strong><code>pubspec.yaml</code></strong> file:</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#85E89D">dependencies</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#85E89D">  flutter</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#85E89D">    sdk</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">flutter</span></span>
<span class="line"><span style="color:#85E89D">  flutter_bloc</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^8.1.5</span></span>
<span class="line"><span style="color:#85E89D">  hive</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^2.0.4</span></span>
<span class="line"><span style="color:#85E89D">  hive_flutter</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^1.1.0</span></span>
<span class="line"><span style="color:#85E89D">  rxdart</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^0.27.2</span></span>
<span class="line"><span style="color:#85E89D">  dartz</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^0.10.0</span></span>
<span class="line"><span style="color:#85E89D">  bloc</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^7.0.0</span></span>
<span class="line"><span style="color:#85E89D">  connectivity_plus</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^1.0.6</span></span>
<span class="line"><span style="color:#85E89D">  dio</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^4.0.0</span></span>
<span class="line"><span style="color:#85E89D">  internet_connection_checker</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">^0.0.1</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<p>Create the necessary folders in your project directory according to the provided folder structure. This is the folder structure I use for simplicity, use the one you like and feel more comfortable with.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>- lib</span></span>
<span class="line"><span>  - presentation</span></span>
<span class="line"><span>    - bloc</span></span>
<span class="line"><span>    - views</span></span>
<span class="line"><span>    - widgets</span></span>
<span class="line"><span>  - repositories</span></span>
<span class="line"><span>  - services</span></span>
<span class="line"><span>    - local_storage_service</span></span>
<span class="line"><span>    - remote_service</span></span>
<span class="line"><span>  - models</span></span>
<span class="line"><span>  - core</span></span>
<span class="line"><span></span></span></code></pre>
<p><strong>ToDo App Features:</strong></p>
<ul>
<li>Ability to add, edit, and delete ToDo items.</li>
<li>List of ToDo items displayed in the app.</li>
<li>Offline storage of ToDo items using Hive.</li>
<li>Background synchronization with a remote server using BLoC and Dio.</li>
</ul>
<p><strong>Note: Basic Setup</strong></p>
<p>For this practical example, we won’t cover basic setup tasks such as creating the Flutter project, initializing dependencies, and other initial configurations. Instead, we’ll focus on building the core functionality of an Offline-First app using Flutter. If you want to see the full project, it will be available on my GitHub, with a link at the end of the blog.</p>
<p>The app will include modules for data models, local storage service, remote service, repository layer, BLoC layer, and UI layer. Each module will be responsible for a specific aspect of the app’s functionality, making the codebase organized and easy to understand.</p>
<p>If you’re new to Flutter or need assistance with project setup, you can refer to official documentation and tutorials available online. Once you have your project set up and dependencies installed, you can follow along with the practical example to implement the Offline-First ToDo app.</p>
<p>Let’s start with the first module:</p>
<h3 id="data-models">Data Models</h3>
<p>We will have the ToDo model and the Remote Operation model. We won’t go into detail of the ToDo model, instead we will focus on the Remote Operation model. This model will help us store al the operations we can’t do in the server while we don’t have an internet connection.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>class RemoteOperation {</span></span>
<span class="line"><span>  final String endpoint;</span></span>
<span class="line"><span>  final HTTPMethod method;</span></span>
<span class="line"><span>  final Map&#x3C;String, dynamic> body;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  RemoteOperation({</span></span>
<span class="line"><span>    required this.endpoint,</span></span>
<span class="line"><span>    required this.method,</span></span>
<span class="line"><span>    required this.body,</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  RemoteOperation copyWith({</span></span>
<span class="line"><span>    String? endpoint,</span></span>
<span class="line"><span>    HTTPMethod? method,</span></span>
<span class="line"><span>    Map&#x3C;String, dynamic>? body,</span></span>
<span class="line"><span>  }) {</span></span>
<span class="line"><span>    return RemoteOperation(</span></span>
<span class="line"><span>      endpoint: endpoint ?? this.endpoint,</span></span>
<span class="line"><span>      method: method ?? this.method,</span></span>
<span class="line"><span>      body: body ?? this.body,</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  factory RemoteOperation.fromJson(Map&#x3C;String, dynamic> json) {</span></span>
<span class="line"><span>    return RemoteOperation(</span></span>
<span class="line"><span>      endpoint: json['endpoint'] as String,</span></span>
<span class="line"><span>      method: HTTPMethod.fromJson(json['method']),</span></span>
<span class="line"><span>      body: json['body'] as Map&#x3C;String, dynamic>,</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Map&#x3C;String, dynamic> toJson() {</span></span>
<span class="line"><span>    return {</span></span>
<span class="line"><span>      'endpoint': endpoint,</span></span>
<span class="line"><span>      'method': HTTPMethod.toJson(method),</span></span>
<span class="line"><span>      'body': body,</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>enum HTTPMethod {</span></span>
<span class="line"><span>  get,</span></span>
<span class="line"><span>  post,</span></span>
<span class="line"><span>  put,</span></span>
<span class="line"><span>  delete;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  static String toJson(HTTPMethod method) {</span></span>
<span class="line"><span>    switch (method) {</span></span>
<span class="line"><span>      case HTTPMethod.get:</span></span>
<span class="line"><span>        return 'GET';</span></span>
<span class="line"><span>      case HTTPMethod.post:</span></span>
<span class="line"><span>        return 'POST';</span></span>
<span class="line"><span>      case HTTPMethod.put:</span></span>
<span class="line"><span>        return 'PUT';</span></span>
<span class="line"><span>      case HTTPMethod.delete:</span></span>
<span class="line"><span>        return 'DELETE';</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  static HTTPMethod fromJson(String method) {</span></span>
<span class="line"><span>    switch (method) {</span></span>
<span class="line"><span>      case 'GET':</span></span>
<span class="line"><span>        return HTTPMethod.get;</span></span>
<span class="line"><span>      case 'POST':</span></span>
<span class="line"><span>        return HTTPMethod.post;</span></span>
<span class="line"><span>      case 'PUT':</span></span>
<span class="line"><span>        return HTTPMethod.put;</span></span>
<span class="line"><span>      case 'DELETE':</span></span>
<span class="line"><span>        return HTTPMethod.delete;</span></span>
<span class="line"><span>      default:</span></span>
<span class="line"><span>        throw Exception('Invalid HTTPMethod');</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>The <strong>RemoteOperation</strong> model represents an operation to be performed on a remote server. It includes the following properties:</p>
<ul>
<li><strong>endpoint</strong>: The endpoint or URL where the operation should be performed.</li>
<li><strong>method</strong>: The HTTP method to be used for the operation (GET, POST, PUT, DELETE).</li>
<li><strong>body</strong>: The payload or data to be sent with the operation.</li>
</ul>
<p>The model provides methods for JSON serialization and deserialization, similar to the <strong>ToDo</strong> model. Additionally, it includes an enumeration <strong>HTTPMethod</strong> to represent the HTTP methods, with helper methods to convert between <strong>String</strong> and <strong>HTTPMethod</strong> values.</p>
<h3 id="local-storage-service">Local Storage Service</h3>
<p>The <strong>LocalStorageService</strong> class manages local data storage using Hive, a lightweight and fast NoSQL database for Flutter. It includes methods for managing ToDo items and remote operations, providing functionality for CRUD operations and cache management.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import 'dart:convert';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import 'package:rxdart/rxdart.dart';</span></span>
<span class="line"><span>import 'package:hive_flutter/hive_flutter.dart';</span></span>
<span class="line"><span>import 'package:todo_offline_first_tutorial/lib.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class LocalStorageService {</span></span>
<span class="line"><span>  const LocalStorageService({</span></span>
<span class="line"><span>    required Box&#x3C;String> hiveBox,</span></span>
<span class="line"><span>  }) : _hiveBox = hiveBox;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  final Box&#x3C;String> _hiveBox;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;void> addCacheRemoteOperation(RemoteOperation remoteOperation) async {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final remoteOperations = getCacheRemoteOperations()..add(remoteOperation);</span></span>
<span class="line"><span>      return await setCacheRemoteOperations(remoteOperations);</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw CacheException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  List&#x3C;RemoteOperation> getCacheRemoteOperations() {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final jsonStr = _hiveBox.get('CachedRemoteOperations');</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      if (jsonStr == null) return [];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      final result = jsonDecode(jsonStr) as List&#x3C;dynamic>;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      return result</span></span>
<span class="line"><span>          .map((json) => RemoteOperation.fromJson(json as Map&#x3C;String, dynamic>))</span></span>
<span class="line"><span>          .toList();</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw CacheException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;void> removeCacheRemoteOperations() async {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      return await _hiveBox.delete('CachedRemoteOperations');</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw CacheException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;void> removeCacheRemoteOperation(RemoteOperation remoteOperation) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final remoteOperations = getCacheRemoteOperations();</span></span>
<span class="line"><span>      final index = remoteOperations.indexWhere(</span></span>
<span class="line"><span>          (cacheRemoteOperation) => cacheRemoteOperation == remoteOperation);</span></span>
<span class="line"><span>      remoteOperations.removeAt(index);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      return setCacheRemoteOperations(remoteOperations);</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw CacheException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;void> setCacheRemoteOperations(</span></span>
<span class="line"><span>      List&#x3C;RemoteOperation> remoteOperations) async {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      await _hiveBox.put(</span></span>
<span class="line"><span>        'CachedRemoteOperations',</span></span>
<span class="line"><span>        jsonEncode(remoteOperations),</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw CacheException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p><strong>Remote Operation Operations:</strong></p>
<ul>
<li><strong>remoteOperationStream</strong>: Returns a stream of remote operations from the Hive box. It watches for changes in the <strong>CachedRemoteOperations</strong> key and maps the JSON string to a list of <strong>RemoteOperation</strong> objects.</li>
<li><strong>addCacheRemoteOperation</strong>: Adds a new remote operation to the cache list.</li>
<li><strong>getCacheRemoteOperations</strong>: Retrieves the list of remote operations from the cache.</li>
<li><strong>removeCacheRemoteOperations</strong>: Removes all remote operations from the cache.</li>
<li><strong>removeCacheRemoteOperation</strong>: Removes a specific remote operation from the cache list.</li>
<li><strong>setCacheRemoteOperations</strong>: Sets the remote operations list in the cache by encoding it to JSON and storing it in the Hive box.</li>
</ul>
<p>While ToDo cache operations are not included in this code section, they are available on the full project at Github. This operations include adding, editing and deleting ToDo items. We also use a stream that goes all the way to the UI for automatic updates.</p>
<h3 id="remote-service">Remote Service</h3>
<p>The <strong>RemoteService</strong> class handles communication with the remote server using Dio, a powerful HTTP client for Dart. It provides methods for performing CRUD operations on ToDo items and synchronizing remote operations.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import 'package:todo_offline_first_tutorial/lib.dart';</span></span>
<span class="line"><span>import 'package:dio/dio.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class RemoteService {</span></span>
<span class="line"><span>  const RemoteService(Dio dio) : _dio = dio;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  final Dio _dio;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	// ToDo operations go here</span></span>
<span class="line"><span>	// Full code available at my GitHub</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;void> synchronize(RemoteOperation remoteOperation) async {</span></span>
<span class="line"><span>    Response&#x3C;dynamic> response;</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final methods = {</span></span>
<span class="line"><span>        HTTPMethod.get: _dio.get&#x3C;Map&#x3C;String, dynamic>>,</span></span>
<span class="line"><span>        HTTPMethod.post: _dio.post&#x3C;Map&#x3C;String, dynamic>>,</span></span>
<span class="line"><span>        HTTPMethod.put: _dio.put&#x3C;Map&#x3C;String, dynamic>>,</span></span>
<span class="line"><span>        HTTPMethod.delete: _dio.delete&#x3C;Map&#x3C;String, dynamic>>,</span></span>
<span class="line"><span>      };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      var method = methods[remoteOperation.method];</span></span>
<span class="line"><span>      if (method != null) {</span></span>
<span class="line"><span>        response = await method(</span></span>
<span class="line"><span>          remoteOperation.endpoint,</span></span>
<span class="line"><span>          data: remoteOperation.body,</span></span>
<span class="line"><span>        );</span></span>
<span class="line"><span>      } else {</span></span>
<span class="line"><span>        throw UnknownNetworkException();</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    } on DioException catch (e) {</span></span>
<span class="line"><span>      if (e.type == DioExceptionType.connectionTimeout ||</span></span>
<span class="line"><span>          e.type == DioExceptionType.sendTimeout ||</span></span>
<span class="line"><span>          e.type == DioExceptionType.receiveTimeout) {</span></span>
<span class="line"><span>        throw TimeoutException();</span></span>
<span class="line"><span>      } else if (e.type == DioExceptionType.connectionError) {</span></span>
<span class="line"><span>        throw ConnectionErrorException();</span></span>
<span class="line"><span>      } else {</span></span>
<span class="line"><span>        throw UnknownNetworkException();</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      throw UnknownNetworkException();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (response.statusCode != 200) {</span></span>
<span class="line"><span>      parseErrorCodeToException(response.statusCode ?? 0);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<ul>
<li><strong>ToDo Operations:</strong>
<ul>
<li><strong>createTodo</strong>: Sends a POST request to create a new ToDo item on the server.</li>
<li><strong>updateTodo</strong>: Sends a PUT request to update an existing ToDo item on the server.</li>
<li><strong>deleteTodo</strong>: Sends a DELETE request to delete a ToDo item on the server by its ID.</li>
<li><strong>getTodos</strong>: Sends a GET request to fetch all ToDo items from the server.</li>
</ul>
</li>
<li><strong>Synchronization:</strong>
<ul>
<li><strong>synchronize</strong>: Executes a remote operation by sending an appropriate HTTP request based on the provided <strong>RemoteOperation</strong>. It handles GET, POST, PUT, and DELETE methods. If any exception occurs during the request, it throws the corresponding exception (<strong>TimeoutException</strong>, <strong>ConnectionErrorException</strong>, or <strong>UnknownNetworkException</strong>). It also checks the response status code and throws an exception if it’s not 200.</li>
</ul>
</li>
</ul>
<h3 id="repositories">Repositories</h3>
<p><strong>DataSynchronizationRepository:</strong></p>
<p>The <strong>DataSynchronizationRepository</strong> is responsible for handling data synchronization between the local cache and the remote server.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import 'package:todo_offline_first_tutorial/lib.dart';</span></span>
<span class="line"><span>import 'package:dartz/dartz.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class DataSynchronizationRepository {</span></span>
<span class="line"><span>  const DataSynchronizationRepository({</span></span>
<span class="line"><span>    required this.localStorageService,</span></span>
<span class="line"><span>    required this.remoteService,</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  final LocalStorageService localStorageService;</span></span>
<span class="line"><span>  final RemoteService remoteService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;bool> doNeedToSynchronize() async {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final remoteOperations = localStorageService.getCacheRemoteOperations();</span></span>
<span class="line"><span>      return remoteOperations.isNotEmpty;</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      return false;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Future&#x3C;Either&#x3C;Failure, Unit>> synchronizeData() async {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>      final remoteOperations = localStorageService.getCacheRemoteOperations();</span></span>
<span class="line"><span>      for (final remoteOperation in remoteOperations) {</span></span>
<span class="line"><span>        await remoteService.synchronize(remoteOperation);</span></span>
<span class="line"><span>        await localStorageService.removeCacheRemoteOperation(remoteOperation);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      return const Right(unit);</span></span>
<span class="line"><span>    } catch (e) {</span></span>
<span class="line"><span>      return Left(ParseYourErrorHere());</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p><strong>Methods:</strong></p>
<ul>
<li><strong>doNeedToSynchronize</strong>: Checks if there are any pending remote operations in the local cache. Returns <strong>true</strong> if there are operations pending synchronization, otherwise <strong>false</strong>.</li>
<li><strong>synchronizeData</strong>: Synchronizes data by fetching pending remote operations from the local cache, executing them using the <strong>RemoteService</strong>, and then removing them from the local cache once they are synchronized. It returns <strong>Right(unit)</strong> on successful synchronization and <strong>Left</strong> with a failure object if an error occurs</li>
</ul>
<p>We also have a ToDo Repository that handles all the logic for creating, editing and deleting ToDo’s. A stream that comes from the local service comunicates the cached ToDo’s with the BLoC.</p>
<ul>
<li><strong>Methods:</strong>
<ul>
<li><strong>get todoList</strong>: Returns a stream of ToDo items from the local storage service.</li>
<li><strong>getTodos</strong>: Retrieves ToDo items from the remote server if there is an internet connection, storing them in the local cache. It returns <strong>Right(unit)</strong> on success or <strong>Left</strong> with a failure object on error.</li>
<li><strong>createToDo</strong>: Adds a new ToDo item locally and then attempts to create it on the remote server. If there is no internet connection, it stores the operation in the local cache for later synchronization. Returns <strong>Right(unit)</strong> on success or <strong>Left</strong> with a failure object on error.</li>
<li><strong>deleteTodo</strong>: Deletes a ToDo item locally and tries to delete it from the remote server. If there is no internet connection, it stores the operation in the local cache for later synchronization. Returns <strong>Right(unit)</strong> on success or <strong>Left</strong> with a failure object on error.</li>
<li><strong>updateToDo</strong>: Updates a ToDo item locally and then attempts to update it on the remote server. If there is no internet connection, it stores the operation in the local cache for later synchronization. Returns <strong>Right(unit)</strong> on success or <strong>Left</strong> with a failure object on error.</li>
</ul>
</li>
</ul>
<h3 id="blocs">BLoCs</h3>
<p><strong>Connection Monitoring BLoC</strong></p>
<p>The connection monitoring BLoC is responsible for managing and monitoring the device’s internet connection and triggering data synchronization when necessary.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import 'dart:async';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import 'package:bloc/bloc.dart';</span></span>
<span class="line"><span>import 'package:connectivity_plus/connectivity_plus.dart';</span></span>
<span class="line"><span>import 'package:flutter/material.dart';</span></span>
<span class="line"><span>import 'package:internet_connection_checker/internet_connection_checker.dart';</span></span>
<span class="line"><span>import 'package:todo_offline_first_tutorial/lib.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>part 'connection_monitoring_event.dart';</span></span>
<span class="line"><span>part 'connection_monitoring_state.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class ConnectionMonitoringBloc</span></span>
<span class="line"><span>    extends Bloc&#x3C;ConnectionMonitoringEvent, ConnectionMonitoringState> {</span></span>
<span class="line"><span>  ConnectionMonitoringBloc({</span></span>
<span class="line"><span>    required DataSynchronizationRepository dataSynchronizationRepository,</span></span>
<span class="line"><span>    required Connectivity connectivity,</span></span>
<span class="line"><span>    required InternetConnectionChecker internetConnectionChecker,</span></span>
<span class="line"><span>  })  : _dataSynchronizationRepository = dataSynchronizationRepository,</span></span>
<span class="line"><span>        _connectivity = connectivity,</span></span>
<span class="line"><span>        _internetConnectionChecker = internetConnectionChecker,</span></span>
<span class="line"><span>        super(ConnectionMonitoringInitial()) {</span></span>
<span class="line"><span>    on&#x3C;MonitorConnectionChanges>(_onMonitorConnectionChanges);</span></span>
<span class="line"><span>    on&#x3C;CheckConnection>(_onCheckConnection);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  final DataSynchronizationRepository _dataSynchronizationRepository;</span></span>
<span class="line"><span>  final Connectivity _connectivity;</span></span>
<span class="line"><span>  final InternetConnectionChecker _internetConnectionChecker;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FutureOr&#x3C;void> _onMonitorConnectionChanges(</span></span>
<span class="line"><span>    MonitorConnectionChanges event,</span></span>
<span class="line"><span>    Emitter&#x3C;ConnectionMonitoringState> emit,</span></span>
<span class="line"><span>  ) async {</span></span>
<span class="line"><span>    final connectionStream = _connectivity.onConnectivityChanged;</span></span>
<span class="line"><span>    await emit.onEach(</span></span>
<span class="line"><span>      connectionStream,</span></span>
<span class="line"><span>      onData: (value) {</span></span>
<span class="line"><span>        add(CheckConnection());</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FutureOr&#x3C;void> _onCheckConnection(</span></span>
<span class="line"><span>    CheckConnection event,</span></span>
<span class="line"><span>    Emitter&#x3C;ConnectionMonitoringState> emit,</span></span>
<span class="line"><span>  ) async {</span></span>
<span class="line"><span>    final hasInternetConnection =</span></span>
<span class="line"><span>        await _internetConnectionChecker.hasConnection;</span></span>
<span class="line"><span>    if (hasInternetConnection) {</span></span>
<span class="line"><span>      final needToSynchronize =</span></span>
<span class="line"><span>          await _dataSynchronizationRepository.doNeedToSynchronize();</span></span>
<span class="line"><span>      if (needToSynchronize) {</span></span>
<span class="line"><span>        emit(ConnectionMonitoringSynchronizing());</span></span>
<span class="line"><span>        final result = await _dataSynchronizationRepository.synchronizeData();</span></span>
<span class="line"><span>        result.fold(</span></span>
<span class="line"><span>          (failure) {</span></span>
<span class="line"><span>            return emit(ConnectionMonitoringSynchronizationFailed());</span></span>
<span class="line"><span>          },</span></span>
<span class="line"><span>          (_) {</span></span>
<span class="line"><span>            return emit(ConnectionMonitoringSynchronized());</span></span>
<span class="line"><span>          },</span></span>
<span class="line"><span>        );</span></span>
<span class="line"><span>      } else {</span></span>
<span class="line"><span>        return emit(ConnectionMonitoringSynchronized());</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>      return emit(</span></span>
<span class="line"><span>        ConnectionMonitoringNoConnection(),</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>part of 'connection_monitoring_bloc.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@immutable</span></span>
<span class="line"><span>sealed class ConnectionMonitoringEvent {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class MonitorConnectionChanges extends ConnectionMonitoringEvent {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class CheckConnection extends ConnectionMonitoringEvent {}</span></span>
<span class="line"><span></span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>part of 'connection_monitoring_bloc.dart';</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@immutable</span></span>
<span class="line"><span>sealed class ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class ConnectionMonitoringInitial extends ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class ConnectionMonitoringSynchronizing</span></span>
<span class="line"><span>    extends ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class ConnectionMonitoringSynchronized</span></span>
<span class="line"><span>    extends ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class ConnectionMonitoringSynchronizationFailed</span></span>
<span class="line"><span>    extends ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>final class ConnectionMonitoringNoConnection</span></span>
<span class="line"><span>    extends ConnectionMonitoringState {}</span></span>
<span class="line"><span></span></span></code></pre>
<ul>
<li><strong>Events:</strong>
<ul>
<li><strong>MonitorConnectionChanges</strong>: Indicates a request to monitor changes in the device’s connectivity status.</li>
<li><strong>CheckConnection</strong>: Indicates a request to check the current internet connection status.</li>
</ul>
</li>
<li><strong>States:</strong>
<ul>
<li><strong>ConnectionMonitoringInitial</strong>: Initial state before any monitoring or synchronization occurs.</li>
<li><strong>ConnectionMonitoringSynchronizing</strong>: State indicating that data synchronization is in progress.</li>
<li><strong>ConnectionMonitoringSynchronized</strong>: State indicating that data synchronization has been successfully completed.</li>
<li><strong>ConnectionMonitoringSynchronizationFailed</strong>: State indicating that data synchronization has failed.</li>
<li><strong>ConnectionMonitoringNoConnection</strong>: State indicating that there is no internet connection available.</li>
</ul>
</li>
<li><strong>Methods:</strong>
<ul>
<li><strong>_onMonitorConnectionChanges</strong>: Listens for changes in the device’s connectivity status and triggers a <strong>CheckConnection</strong> event.</li>
<li><strong>_onCheckConnection</strong>: Checks the current internet connection status and performs data synchronization if there is an internet connection available. It emits appropriate states based on the synchronization process.</li>
</ul>
</li>
</ul>
<p>This BLoC encapsulates the logic for monitoring the device’s connectivity, checking for internet availability, and initiating data synchronization accordingly.</p>
<p>We also have a ToDo’s BLoC for managing all things related to creating, updating and deleting items. This BLoC manages the todo state and handles todo-related events by interacting with the <strong>ToDoRepository</strong>.</p>
<h3 id="ui-layer">UI Layer</h3>
<p>In the UI Layer we will have our BLoC provider adding the event for monitoring the connection changes.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span> MultiBlocProvider(</span></span>
<span class="line"><span>      providers: [</span></span>
<span class="line"><span>	      // Bloc for monitoring connection changes</span></span>
<span class="line"><span>        BlocProvider(</span></span>
<span class="line"><span>          create: (context) => ConnectionMonitoringBloc(</span></span>
<span class="line"><span>            dataSynchronizationRepository: sl(),</span></span>
<span class="line"><span>            connectivity: sl(),</span></span>
<span class="line"><span>            internetConnectionChecker: sl(),</span></span>
<span class="line"><span>          )..add(</span></span>
<span class="line"><span>              MonitorConnectionChanges(),</span></span>
<span class="line"><span>            ),</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>        // Bloc for managing todo operations</span></span>
<span class="line"><span>        BlocProvider(</span></span>
<span class="line"><span>          create: (context) => TodoBloc(sl())</span></span>
<span class="line"><span>            ..add(LoadToDos()) // Load todos from local storage</span></span>
<span class="line"><span>            ..add(ListenToToDosInCache()), // Listen to changes in cached todos</span></span>
<span class="line"><span>        ),</span></span>
<span class="line"><span>      ],</span></span>
<span class="line"><span>     )</span></span>
<span class="line"><span>     // Rest of code</span></span>
<span class="line"><span></span></span></code></pre>
<p>In our main ToDo list screen we will have a BLoC listener that triggers Snackbars for displaying data synchronization and internet connection information.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>BlocListener&#x3C;ConnectionMonitoringBloc, ConnectionMonitoringState>(</span></span>
<span class="line"><span>      listener: (context, state) {</span></span>
<span class="line"><span>        return switch (state) {</span></span>
<span class="line"><span>          ConnectionMonitoringSynchronized() =></span></span>
<span class="line"><span>            context.read&#x3C;TodoBloc>().add(LoadToDos()),</span></span>
<span class="line"><span>          ConnectionMonitoringNoConnection() =></span></span>
<span class="line"><span>            ScaffoldMessenger.of(context).showSnackBar(</span></span>
<span class="line"><span>              SnackBar(</span></span>
<span class="line"><span>                content: const Text(</span></span>
<span class="line"><span>                  'No internet connection',</span></span>
<span class="line"><span>                  style: TextStyle(color: Colors.red),</span></span>
<span class="line"><span>                ),</span></span>
<span class="line"><span>                backgroundColor: Colors.grey.shade800,</span></span>
<span class="line"><span>              ),</span></span>
<span class="line"><span>            ),</span></span>
<span class="line"><span>          ConnectionMonitoringSynchronizing() =></span></span>
<span class="line"><span>            ScaffoldMessenger.of(context).showSnackBar(</span></span>
<span class="line"><span>              SnackBar(</span></span>
<span class="line"><span>                content: const Text('Synchronizing data',</span></span>
<span class="line"><span>                    style: TextStyle(color: Colors.yellow)),</span></span>
<span class="line"><span>                backgroundColor: Colors.grey.shade800,</span></span>
<span class="line"><span>              ),</span></span>
<span class="line"><span>            ),</span></span>
<span class="line"><span>          ConnectionMonitoringSynchronizationFailed() =></span></span>
<span class="line"><span>            ScaffoldMessenger.of(context).showSnackBar(</span></span>
<span class="line"><span>              SnackBar(</span></span>
<span class="line"><span>                content: const Text('Failed to synchronize data',</span></span>
<span class="line"><span>                    style: TextStyle(color: Colors.red)),</span></span>
<span class="line"><span>                backgroundColor: Colors.grey.shade800,</span></span>
<span class="line"><span>              ),</span></span>
<span class="line"><span>            ),</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>      // OTHER UI CODE </span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span></span></span></code></pre>
<h2 id="conclusion"><strong>Conclusion</strong></h2>
<p>In this blog, we’ve delved into the concept of offline-first mobile app development, exploring its importance, benefits, and implementation strategies. Here’s a summary of key points covered:</p>
<ol>
<li><strong>Understanding Offline-First:</strong>
<ul>
<li>Offline-first development prioritizes creating apps that remain functional even without an internet connection.</li>
<li>It enhances user experience by reducing reliance on network connectivity and providing seamless interactions.</li>
</ul>
</li>
<li><strong>Benefits of Offline-First:</strong>
<ul>
<li>Improved user experience: Users can access and interact with the app regardless of network availability, reducing frustration and increasing engagement.</li>
<li>Increased reliability: By storing data locally and synchronizing with a remote server when possible, offline-first apps are less prone to data loss and inconsistencies.</li>
<li>Cost savings: Reduced network usage can lead to lower data costs for users and lower server costs for app developers.</li>
</ul>
</li>
<li><strong>Implementation Strategies:</strong>
<ul>
<li><strong>Local Data Storage:</strong> Utilize local databases like SQLite, Hive, or shared preferences to store data locally on the device.</li>
<li><strong>Data Synchronization:</strong> Implement mechanisms to synchronize local data with a remote server when an internet connection is available.</li>
<li><strong>Connection Monitoring:</strong> Monitor network connectivity and adapt the app’s behavior accordingly, providing feedback to users about their connection status.</li>
</ul>
</li>
<li><strong>Key Technologies:</strong>
<ul>
<li><strong>Flutter:</strong> A cross-platform framework for building mobile apps, which offers rich features and performance suitable for offline-first development.</li>
<li><strong>Dio:</strong> A powerful HTTP client for Flutter, used for making network requests and interacting with remote servers.</li>
<li><strong>Hive:</strong> A lightweight and fast NoSQL database for Flutter, ideal for local data storage in offline-first apps.</li>
<li><strong>Bloc Pattern:</strong> A state management pattern for Flutter that helps in managing complex state and business logic, making it suitable for offline-first apps.</li>
</ul>
</li>
<li><strong>Best Practices:</strong>
<ul>
<li><strong>Modular Architecture:</strong> Divide the app into layers (data, repository, blocs, UI) to maintain separation of concerns and facilitate scalability and maintainability.</li>
<li><strong>Dependency Injection:</strong> Use dependency injection to provide dependencies to different parts of the app, making the codebase more testable and maintainable.</li>
<li><strong>Error Handling:</strong> Implement robust error handling mechanisms to gracefully handle network failures and other errors that may occur in offline scenarios.</li>
</ul>
</li>
</ol>
<p>By adopting the offline-first approach and following best practices and implementation strategies outlined in this blog, developers can create mobile apps that provide a reliable and consistent user experience, even in challenging network conditions.</p>
<h3 id="link-to-github-project">Link to GitHub project</h3>
<p><a href="https://github.com/marcosvons/online-first-tutorial">GitHub Project</a></p> </article>  </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-5">  <div class="relative"> <div class="absolute right-0 -top-20"> <button id="back-to-top" class="relative group w-fit flex pl-8 pr-3 py-1.5 flex-nowrap rounded border border-black/15 dark:border-white/20 hover:bg-black/5 dark:hover:bg-white/5 hover:text-black dark:hover:text-white transition-colors duration-300 ease-in-out"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute top-1/2 left-2 -translate-y-1/2 size-4 stroke-2 fill-none stroke-current rotate-90"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 group-hover:translate-x-0 scale-x-0 group-hover:scale-x-100 transition-transform duration-300 ease-in-out"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 group-hover:translate-x-0 transition-transform duration-300 ease-in-out"></polyline> </svg> <div class="text-sm">
Back to top
</div> </button> </div> </div> <div class="flex justify-between items-center"> <div>
&copy; 2024 | Marcos von Stremayr </div> <div class="flex flex-wrap gap-1 items-center"> <button id="light-theme-button" aria-label="Light theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect> <line x1="8" y1="21" x2="16" y2="21"></line> <line x1="12" y1="17" x2="12" y2="21"></line> </svg> </button> </div> </div>  </div> </footer> </body></html>